
# Swift

안녕하세요 하울의 IOS 강좌에 오신것을 환영합니다 저는  **유튜브**에서  **Howlab**을 운영하고 있구요. **안드로이드**, **IOS** 앱 개발 경험을 가지고 있습니다.

## Swift 장점 특징
- **쉬운 언어** - 스위프트는 파이썬(Python)에 필적하는 간단한 문법으로 사용하기 쉽게 구축되어있으며 스위프트의 법칙을 조금만 안다면 같은 함수형 언어인 자바스크립트, 타입스크립트 코틀린, 파이썬등 금방 사용할 수 있을 것 입니다.
- **오픈소스** -  두번째 장점으로는 스위프트는 **오픈소스 언어** 입니다.  단지 **IOS**, **MACOS **프로그램만 개발하는 언어가 아닌 다른 플렛폼에도 개발을 할 수 있도록 애플이 라이센스를 개방해 놓았습니다. 현재 Swift기반의 서버사이드 개발되고 있으면 몇년전에는 구글에서 코틀린을 공식 안드로이드 언어로 지정하기 전에 스위프트를 공식언어로 검토한적이 있습니다.
- **빠른 컴파일 속도** - 애플의 주장에 따르면 검색 알고리즘 완성 속도가 기존 IOS 개발에 쓰였던 오브젝티브-C(Objective-C)보다는 최대 **2.6배**, 파이썬 2.7 버전보다는 최대 **8.4배** 빠르다고 한다.
 -  **OPTIONAL 도입** - 코드중에 프로그램을 가장 불완전하게 만드는 것이 Null, Nil 값에 대한 오류이다. 이 폭탄과 같은 Null, Nil값을 사전에 방지시키고자 하는 것이 Optional 입니다.
-  **클로저 지원** - 클로저를 다른 명칭으로 람다 혹은 익명함수 라고 지칭하기도 합니다. 종종 함수를 일회용으로 사용할 경우 많이 쓰입니다.  클로저를 사용하면 표현식을 간편하게 만들 수가 있습니다. 함수식이 간편하면 컴파일 속도 빨라지고 가독성이 좋아지는 장점이 있습니다.
---- 
## Swift 기본문법
### 변수선언
그럼 간단히 **Variable**(변수)를 선언방법을 살펴보도록 하겠습니다. 기본적으로 값을 넣을때 가장 많이 쓰이는 방법이며 데이터 교체가 가능한것이 특징입니다. 사용방법은 **var** 을 입력해서 선언하시면 됩니다. 또한 초기값은 나중에 넣어주어도 됩니다.
#### 기본선언 방식
```swift
var 변수명 : 변수형식 = 입력할 값
```

#### 실제 예제
```swift
var i : Int = 1 
```

#### 변수 변경
```swift
var i : Int = 1
i = 2
print("i 값이 $i 입니다.")
```

##### Console
> i 값이 2 입니다.
#### 변수 형식 생략
```swift
var i = 1 
```
뒤에 **int** 값을 생략해서 변수를 선언 할 수 있다. 그럴 경우 컴파일러는 뒤에 입력되는 값에 따라서 변수타입을 선언하게 된다.

### 상수선언
상수란 입력된 값이 수정되지 않은 것을 말합니다. 종종 프로그램 안성정을 위해서 값이 변경되지 않아햐 할 경우가 있는데 이때 사용됩니다. 사용방법은  **let** 을 입력해서 선언하시면 됩니다. 주의해야할점은 초기값은 반드시 넣어주어야 합니다.

#### 기본선언 방식
```swift
let 변수명 : 변수형식 = 입력할 값
```
#### 실제 예제
```swift
let i : Int = 1 
```

#### 변수 변경
```swift
let i : Int = 1
i = 2
print("i 값이 $i 입니다.")
```

##### Console
> 컴파일 에러

#### 변수 형식 생략
```swift
let i = 1 
```
뒤에 **int** 값을 생략해서 변수를 선언 할 수 있다. 그럴 경우 컴파일러는 뒤에 입력되는 값에 따라서 변수타입을 선언하게 된다.

#### 다른 변수들
물론 숫자(**Int**) 말고도 논리값(**Boolean**), 문자열(**String**), 배열(**Array**)등을 선언할 수 있다.

- 숫자 
```swift
var i : Int = 1 
var d : Double = 0.1 
```

- 논리값
```swift
var b : Bool = true
```

- 문자열
```swift
var s : String = "문자열"
```

- 배열
```swift
var s : Array<String> = ["하울","캐스퍼"]
var s2 : [String] = ["하울","캐스퍼"]
```


---- 
## Nil과 Null의 차이
이미 프로그래밍을 어느정도 해보신분들은 Nil보다는 Null의 개념이 익숙하실 겁니다. 물론 개발하면 두가지의 의미가 거의 같게 쓰이고 있으니 사실 크게 신경쓰지 않으셔도 되지만 간단히 어떤 차이의 개념이 있는지 살펴보도록 하겠습니다. 

### Null 개념
값이 세상에 존재하지만 주소가 할당되지 않는 것을 말합니다. 현실에 비유하면 물질이 존재 하지만 물질의 좌표가 존재하지 않는 것을 말합니다.
![](Screen%20Shot%202019-10-14%20at%208.19.48%20PM.png)

### Nil 개념
 사물(**Object**)이 세상에 존재하지 않는 것을 말합니다. 현실에 비유하면 빅뱅 우주가 생기기 전 물질이 존재이 존재하지 않는 상태라고 보시됩니다.
![](Screen%20Shot%202019-10-14%20at%208.19.48%20PM-1.png)


## 연산자

### 산술연산자
산술 연산자 산술 연산자는 대표적으로 + - \* / % 있습니다. 이 연산 수식을  모르시는 분들이 거의 없기 때문에 바로 예제를 통해서 살펴보도록 하겠습니다.

#### 더하기
```swift
var x = 6
var y = 3
print("더하기 결과 값이 \(x + y)")
```
##### Console
> "더하기 결과 값이 9”

#### 빼기 
```swift
var x = 6
var y = 3
print("빼기 결과 값이 \(x - y)")
```
##### Console
> "더하기 결과 값이 3”

#### 곱하기
```swift
var x = 6
var y = 3
print("곱하기 결과 값이 \(x * y)")
```
##### Console
> "더하기 결과 값이 18”

#### 나누기
```swift
var x = 6
var y = 3
print("나누기 결과 값이 \(x / y)")
```
##### Console
> "더하기 결과 값이 2”

- 나머지
```swift
var x = 6
var y = 3
print("나머지 결과 값이 \(x % y)")
```
##### Console
> "더하기 결과 값이 1”

### 비교연산자

그럼 이번에는 비교 연산자에 대해서 나가도록 하겠습니다. 비교 연산자는 말 그대로 두 변수를 비교 한다고 생각하면 됩니다.  비교연산자를 통해서 Control Flow를 통제할 수 있습니다.

#### A **\>** B(A가 B보다 큽니까?) 
```swift
var x = 6
var y = 3
print("비교 연산자 결과 값이 \(x > y)")
```
##### Console
> 비교연산자 결과값이 True
#### A **\>=** B(A가 B보다 크거나 같습니까?)
```swift
var x = 6
var y = 3
print("비교 연산자 결과 값이 \(x >= y)")
```
##### Console
> 비교연산자 결과값이 True
- A **\<=** B(A가 B보다 작습니까?)
```swift
var x = 6
var y = 3
print("비교 연산자 결과 값이 \(x > y)")
```
##### Console
> 비교연산자 결과값이 False
#### A **\<=** B(A가 B보다 작거나 같습니까?)
```swift
var x = 6
var y = 3
print("비교 연산자 결과 값이 \(x >= y)")
```
##### Console
> 비교연산자 결과값이 False
#### A **==** B(A와 B가 같습니까?)
```swift
var x = 6
var y = 3
print("비교 연산자 결과 값이 \(x == y)")
```
##### Console
> 비교연산자 결과값이 False
#### A **!=** B(A와 B가 다릅니까?)
```swift
var x = 6
var y = 3
print("비교 연산자 결과 값이 \(x != y)")
```
##### Console
> 비교연산자 결과값이 True

## Control Flow
그럼 이번에는 **Control Flow** 에 대해서 나가도록 하겠습니다. 말 그대로 흐름을 제어 한다고 생각하면 됩니다. 흐름 제어해야 내가 원하는 그림을 그릴 수가 있습니다. **If**, **Switch**, **for**, **while** 4가지의 제어문이 있습니다. 

### IF문
**if**문은 조건문이 맞아야 실행 되는 함수 입니다.  
```swift
if(조건){
// 조건이 참이 경우 실행
}else if(조건){
// 조건이 참일 경우 실행
}else{
// 위 2개 조건 문이 둘다 거짓일 경우 실행
}
```
### Switch문
**Switch**문 **If**문과 비슷한 구조를 가지고 있습니다만 여러 조건문을 한번에 처리할때 사용합니다. 
```swift
switch(x){
    case 1 : print(“x값은 1입니다.”)
	case 2 : print(“x값은 2입니다.”)
	default : print(“x값은 1 또는 2가 아닙니다.)
}
```
### For문
**for**반복적으로 사용 할때  코드를 재사용할때 사용합니다.  크게 For은 2가지 종류가 있습니다. 숫자로 반복하는 **Range For**과  데이터 갯수로 반복하는 **Array For**이 있습니다.

#### 단순 Range For문
```swift
for x in 1…5{
	print (x)
} 
```
##### Console
> 1
> 2
> 3
> 4
> 5

##### 조건 Range For문
```swift
for x in stride(from : 1, to :10, by : 2){
	print (x)
}
```
##### Console
> 1
> 3
> 5
> 7
> 9

#### Array For문
```swift
var array = [1,10,100]
for item in array{
     print(item)
}
```
##### Console
> 1
> 10
> 100
### While문
**while**문 **For**과 같이 코드를 반복적으로 사용할때 사용합니다만 다르게 조건식이 존재합니다.
#### While 문
```swift
var x = 0
while x < 5 {
	x += 1
	print(x)
	//조건문이 참일 경우  계속해서 반복
}
```
##### Console
> 0
> 1
> 2
> 3
> 4

## Function

### 기본형Funtion
이번 영상에는 Fuctions에 대해서 나가도록 하겠습니다.  Function 모든 함수형 언어에서 나오는 기본적인 구조 입니다. 자바에서는 메소드라는 명칭으로 사용하고 있습니다. 간단히 설명을 하면 마치 공장에 원료가 들어가서 최종 배출물로 생산품이 나올 수 있도록 도와주는 팩토리라고 생각하면 됩니다.
##### 선언방법
```swift
func 이름 (파라미터 명: 데이터 형식) -> 리턴값 {
    //프로세서 처리
	return  가공값
}
```

파라메터로 넘어오는 값에 **숫자 4**를 추가하는 Function을 추가하는 예제를 만들어보자.
##### 예제
```swift
func addFour (input : Int) -> Int {
    //프로세서 처리
	return  input + 4
}
```

### Clouser Function


## Optional
Swift에서 새로 도입된 Optional에 대해서 나가도록 하겠습니다. name변수 안에는 여러가지 숫자나 글자를 담을 수가 있습니다. 만약 저 name어떠한값도 한번도 담아지지 않거나 혹은 초기화 되지 않았을때 지칭하는 말이 nil 입니다.  nil 일종에 폭탄과 같은데 어떤 프로세스가 nil값을 읽어드릴 경우 에러가 발생되서 프로그램이 꺼지게 됩니다. 이는 되게 큰 오류인것이죠. 만약 비행기 관련 프로그램을 만들었는데 비행도중에 프로그램이  꺼지면 심각한 상황을 맞이하게 됩니다. 그래서 이 오류를 예방하는 것이 중요하며 결국 Swift에서는 이것을 아에 원천적으로 차단 수 있는 Optional라는 개념을 도입하게 됩니다. 

### 선언방법
```swift
var 이름 : 변수? = “하울”
```
Optional을 선언하는 방법은 데이터 타입 뒤에다가 [?](#)를 넣어주면 됩니다. 보통 변수를 선언할때는 var, 변수이름, 변수형식 입력값 선언하지만  **Optional**로 선언할 때는 변수 형식 뒤에 ?(**물음표**)만 추가주면 됩니다.

![](Screen%20Shot%202019-10-15%20at%202.18.32%20AM.png)

### Optional의 특징
**Optional**를 선언하면 데이터를 보호하게 됩니다. 즉 폭탄과 같은 **Nil**값이 함부로 폭팔하지 않게 보호캡슐화를 시켜준다고 보면 됩니다. 데이터를 캡슐화 하게되면 단점이 하나 있는데 데이터를 포장하는 것과 포장을 푸는 과정이 조금은 번거로우며 또한 **포장된 상태에서는 값을 사용할 수 없는 단점**을 가지고 있습니다.
#### Optional 연산
```swift
var x : Int? = 1
var y : Int? = 1
print(x + y)
```
##### Console
> 에러 발생
**Optional**의 포장을 해제해주지 않아서 문제가 발생합니다.

### Optional 해제
Optional 해제방법에는 2가지가 있습니다. Optional을 해제해주는 이유는 첫번째는 **자동해제**와 **강제해제**가 있습니다. 

1. 강제해제
강제해제를 해주기 위해서는 **!(느낌표)**로 해제를 해주어야 한다. 단순히 안에 **NIL** 있는지 체크하지 않고 무조건 강제해제를 해주는 방식이니 정말 데이터가 신뢰성이 있지 않는 이상 사용하는 것을 권장하지 않는다.
![](Screen%20Shot%202019-10-15%20at%202.18.44%20AM.png)

2. 자동해제
자동해제는 느낌표를 붙히지 않고 자동적으로 **Optinal**가 해제 되는 것을 말합니다.  값이 불완전하거나 혹은 신뢰성이 없을때 사용하는 것을 권장한다 물론 자동해제 방법도 2가지가 있으며 **컴파일 자동해제**와 **IF문 자동해제**가 있다.

![](Screen%20Shot%202019-10-15%20at%202.18.57%20AM.png)
 - 컴파일 자동해제
**String** 변수 만 자동적으로 Swift 컴파일러가 지원한다.
- IF문 자동해제
 if 문안에 **let**를 사용한 예제를 볼 수가 있다. 먼저 옵셔널로 선언된 name 변수에 하울이란 값이 있을 경우 이 조건은 자동적으로 **True**되어 IF동작하며 값이 없을 경우 **False**되어 IF문이 동작하지 않는다.
#### 예제
 - IF문 True
```swift
var name : String? = "하울"
if let checkName = name{
    print(checkName)
}
```

 - IF문 False
```swift
var name : String? = nil
if let checkName = name{
    print(checkName)
}
```

### Optional의 대입 및 연산

대입에서 옵셔날이 선언된 변수와 선언되지 않은 변수가 어떻게 호환이 될지 궁금하실 겁니다. 결론적으로 일단 옵셔널이 선언변 변수와 선언되지 않는 변수는 호환이 되지 않습니다.
- 대입
```swift
var howl : String = ""
var name : String? = "하울"

howl = name  //에러 발생
howl = name! //형식을 한쪽으로 통일 시켜주어야함
```

만약 howl이라는 변수를 옵셔널 없이 선언 한후  name이라는 변수를 옵셔널로 선언했을 경우
howl에다가 바로 name을 대입할 수가 없습니다. 먼저 name을 강제적으로 옵셔널을 제거한 이후에 howl변수에 담을 수가 있습니다.

 - 연산
```swift
var a : Int? = 5
var b : Int? = 10

a + b   // 에러 발생
a! + b! // Optional를 제거해주어야 연산이 가능
```

다음으로 연산에서 마찬가지로 옵셔널 숫바 변수 또한 옵셔널을 풀지 않은 이상 연산을 할 수가 없습니다. 만약 a 에 값을 5를 넣고  b에 값을 10을 넣을 경우  바로 a + b를 연산할 수 없고
a 옵셔널 해제 b 옵셔널 해제 이후에 연산을 해제 하셔야 합니다.


## Class

Class를 다른 용어로는 Object 라고 합니다. Object의 뜻은 사물입니다.물론 Class와 Object가 사용하는 뜻 조금 일단 같은 개념이라고 생각을 하고 진행 하도록 하겠습니다.  우리는 컴퓨터나 스마트폰으로 세계를 만들 수가 있는데 그 안에는 어려가지 사물이 있습니다. 
게임을 만들었다고 가정하게되면 자동차 사람 무기 등 있으며 이런 이런 것을 사물이라고 말할 수가 있습니다.  먼저 클래스 구조를 살펴보고 넘어가도록 하겠습니다. 클래스 구조는 크게 2가지 구조로 이루워져 있습니다. 첫번째 변수들이 집한된  **Property**부분이 있으며  두번째는 변수를 가공시키는 **Function**으로 구성으로 되어있습니다. 

1. 클래스 구조
2. 클래스 상속
3. 인터페이스(프로토콜)

### 클래스 선언 방식
![](Screen%20Shot%202019-10-23%20at%208.46.32%20PM.png) 

#### 예제
```swift
class Human{

	var name = "하울"
	
	func printName(){
		print("저의 이름은 \(name)입니다.")
	}
}

Human().printName()
```
> 저의 이름은 하울입니다.
### 클래스 상속

상속이라는 본래 용어는 **Inheritance** 단어를 번역한 것으로 본래 뜻은 유전, 유전적 성질이라는 뜻을 가지고 있습니다. 즉 유전전적인 성질을 부여받는다라고 생각하시면 좀더 이해하기 좋을 것 같습니다. 허가를 주는 방법은 선언자 앞에다가 **open** 명칭을 달아주게 되면 상속을 할 수가 있습니다 또한 변수나 **Function**에 **open**를 달아주게되면 상속을 받은 대상자가 클래스를 수정(**Override**) 할 수 있는 권한을 가지게 됩니다.

### 상속 선언 방식

```swift
class (클래스명) : (상속클래스){
  override init(){
  }
}
```

클래스 명 바로 옆에 콜론 **:** 입력 다음에 상속할 클래스명을 넣어주면 상속을 받을 수 있습니다.

#### 예제
```swift
open class Human{

  	open var name = "하울"
	
	func printName(){
		print("저의 이름은 \(name)입니다.")
	}
}
class American: Human{
     override init(){
         super.init()
         self.name = "잡스"
     }
}

American().printName()
```
> 저의 이름은 잡스입니다.

### 인터페이스(Protocol)

이번에는 가장 중요하다고 생각하는 **Protocol**에 대해서 나가도록 하겠습니다. **Swift**에서는 **Protocol**이라고 하지만 다른 언어에서는 **Interface**라고 불립니다.  요약하면 둘다 같은개념입니다.

#### 프로토콜과 인터페이스의 추가적인 설명(읽지 않아도 됩니다)

![](DraggedImage.tiff)

인터페이스가 추상메소드와 형식이 같다고 설명하는 문제들이 있는데 그건 전혀 쓸모없는 지식들입니다. 전혀 연관되지 않으며 사용법이 다릅니다. 인터페이스의 본래 뜻은 사물과 사물 사이 또는 사물과 인간 사이의 경계에서, 상호 간의 소통을 위해 만들어진 물리적 매개체나 프로토콜을 말한다. 즉 의사소통하는데 필요한 방법을 말하는 것이다.

사람으로 비유하자면 사람은 정보를 상호작용할때 사용하는 통신규격(**Protocol**)이 있구요 이것을 오감이라고 합니다. 사람의 눈 같은 경우는 가시광선만 볼수가 있고 귀같은 경우는  20hz ~ 2만hz이한 들을 수 있도록 설계되어 있습니다. 이 규격이 사실은 **Protocol**이라고 보시면 됩니다.

사람은  **인터페이스** 하기 위해서는 대화를 한다. 여기서 대화를 도와주는 프로토콜이 대표적으로 청각입니다.  
![](http://www.jayoo.co.kr/news/photo/201711/403_288_562.jpg)

눈과 귀가 발달하지 못한 사람은 첨자인 촉각(**Touch**)을 통해서 인터페이스하고 있습니다. 마찬가지로 아직 음성인식이 완전치 않은 스마트폰과 소통하기 위해서는  **Touch**라는 **Protocol**을 통해서 소통 하고 있습니다.

 본론을 돌아와서 **Swift**에서 코딩으로 클래스끼리 소통을 해야하는데 소통을 할때 사용하는 매개체가 **Protocol** 입니다.

#### 인터페이스 선언
```swift
protocol HumanInterface{
	func conversation(v : String)
}

class Human : humanInterface{
	var delegate : HumanInterface?
    
    func converstaion(v : String){
        print("상대방이 \(v)라고 말하는 것을 들었습니다.")
    }
    func sayToOtherPeople(say : String){
        delegate?.converstaion(v: say)
    }
}
```


#### 인터페이스 호출

```swift
var firstHuman = Human()
var SecondHuman = Human()
firstHuman.delegate = SecondHuman
firstHuman.sayToOtherPeople(say: "첫번째사람이라고 합니다.")
```



### 클래스 접근권한

이번에는 접근 권한에 대해서 나가도록 하겠습니다. 변수나 평션또는 클래스를 만들게 되면 외부에서 접근해서 쓰는 경우가 많은데 필요에 따라서  내부에서 접근 제한 시킬 수가 있습니다. 이것을 접근 권한이라고 하며 이것의 종류는 총 3가지가 있습니다. 첫번째는 가장 보안이 높은 private이 있습니다. 두번째는 private보다 보안이 낮은 internal가 있으며
마지막으로 보안을 않는 public 있습니다. 그럼 다음페이지에서 자세히 설명하도록 하겠습니다.

#### Private 
접근 범위 :  클래스
![](Screen%20Shot%202019-10-26%20at%2011.23.45%20PM.png)

#### Internal
접근 범위 :  모듈
![](Screen%20Shot%202019-10-26%20at%2011.25.00%20PM.png)

#### Public
접근 범위 :  전체
![](Screen%20Shot%202019-10-26%20at%2011.25.38%20PM.png)



## Struct
사실 앱을 만드는 이유는 필요한 데이터를 출력하기 위해서 사용하고 있습니다.
데이터들은 앱을 구성하는 핵심적인 요소 핵심적인 요소인 데이터들을 손쉽게 사용할 수 있도록 모델화 것이 Structor 즉 구조체 라고 합나다.

![](DraggedImage-1.tiff)

```
struct Student{
	var grade : Int?
	var name : String?
	var gender : String?
	var birthday : String?
}

var student = Student()
student.grade = 4
student.name = "홍길동"
student.gender = "남"
student.birthday = "2008년 1월 1일"
```
### Nested Struct
일단 Nested struct는 중첩 구조체의 뜻으로 Struct에 안에 또다른 Struct가 있는 것을 말합니다.
![](DraggedImage-2.tiff)

```swift
struct Student{
      var name : String?
      var subject : Subject?
            struct Subject  {
                var math : Int?
                var english : Int?
      }
}
```
